import { EntityManager } from "typeorm";
import { IsolationLevel } from "typeorm/driver/types/IsolationLevel";
import { FindConfig } from "../types/common";
declare type Selector<TEntity> = {
    [key in keyof TEntity]?: unknown;
};
/**
 * Common functionality for Services
 * @interface
 */
declare class BaseService<TChild extends BaseService<TChild, TContainer>, TContainer = unknown> {
    protected readonly configModule: Record<string, unknown>;
    protected transactionManager_: EntityManager | undefined;
    protected manager_: EntityManager;
    private readonly container_;
    constructor(container: TContainer, configModule: Record<string, unknown>);
    withTransaction(): this;
    withTransaction(transactionManager: EntityManager): TChild;
    /**
     * Used to build TypeORM queries.
     * @param selector The selector
     * @param config The config
     * @return The QueryBuilderConfig
     */
    buildQuery_<TEntity = unknown>(selector: Selector<TEntity>, config?: FindConfig<TEntity>): FindConfig<TEntity> & {
        where: {
            [key in keyof TEntity]?: unknown;
        };
        withDeleted?: boolean;
    };
    /**
     * Confirms whether a given raw id is valid. Fails if the provided
     * id is null or undefined. The validate function takes an optional config
     * param, to support checking id prefix and length.
     * @param rawId - the id to validate.
     * @param config - optional config
     * @returns the rawId given that nothing failed
     */
    validateId_(rawId: string, config?: {
        prefix?: string;
        length?: number;
    }): string;
    shouldRetryTransaction(err: {
        code: string;
    } | Record<string, unknown>): boolean;
    /**
     * Wraps some work within a transactional block. If the service already has
     * a transaction manager attached this will be reused, otherwise a new
     * transaction manager is created.
     * @param work - the transactional work to be done
     * @param isolationOrErrorHandler - the isolation level to be used for the work.
     * @param maybeErrorHandlerOrDontFail Potential error handler
     * @return the result of the transactional work
     */
    atomicPhase_(work: (transactionManager: EntityManager) => Promise<unknown>, isolationOrErrorHandler?: IsolationLevel | ((error: unknown) => Promise<unknown>), maybeErrorHandlerOrDontFail?: (error: unknown) => Promise<unknown>): Promise<unknown | never>;
    /**
     * Dedicated method to set metadata.
     * @param obj - the entity to apply metadata to.
     * @param metadata - the metadata to set
     * @return resolves to the updated result.
     */
    setMetadata_(obj: {
        metadata: Record<string, unknown>;
    }, metadata: Record<string, unknown>): Record<string, unknown>;
}
export default BaseService;
